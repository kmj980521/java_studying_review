# REVIEW-JAVA-DAY4
자바 복습하기 4일차

ArrayList(객체 배열) 클래스 사용하기

1. import java.util.ArrayList; 해주기

2.ArrayList 선언은 ArrayList<자료형> 변수 =new ArrayList();

3.변수.add(new 자료형(...)); 를 통해 요소 값 추가 // 생성자 호출

4.변수.size()는 요소의 수

5.변수.get(i)은 i번째 요소의 데이터 값을 얻음.

향상된 for문 
```java
for(Book lang:library)
		{
			lang.showinfo();
		}
```

상위 클래스로 형 변환이 된 하위클래스는 재정의된 메소드(가상 메소드)를 호출한다.

하위 클래스에서 재정의 된 메소드(@Override 애노테이션을 사용)는 오버라이드를 했다.

변수가 사용하는 메모리(힙)와 **메소드가 사용하는 메모리는 다르다**

클래스의 메소드 명령 집합은 **메소드 영역(코드 영역)에 위치** 해서 메소드를 호출하면 메소드 영역의 주소를 참조하여 명령이 실행.

가상메소드의 경우에는 **가상 메소드 테이블**이 따로 만들어진다. 각 메소드 이름과 실제 메모리 주소가 짝을 이루고 있음. 어떤 메소드가 호출되면 이 테이블에서 주소 값을 찾아서 해당 메소드의 명령을 수행

ex) 상위 클래스 a ( 메소드1, 메소드2가 존재) a클래스의 확장인 클래스 b (a의 메소드1을 재정의한 메소드, 재정의되지 않은 메소드2, 추가한 메소드3)
        하위 클래스에서 재정의된 메소드는 하위클래스의 메소드 영역을 참조, 
