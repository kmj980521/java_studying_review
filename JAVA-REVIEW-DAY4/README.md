# REVIEW-JAVA-DAY4
자바 복습하기 4일차

ArrayList(객체 배열) 클래스 사용하기

1. import java.util.ArrayList; 해주기

2.ArrayList 선언은 ArrayList<자료형> 변수 =new ArrayList();

3.변수.add(new 자료형(...)); 를 통해 요소 값 추가 // 생성자 호출

4.변수.size()는 요소의 수

5.변수.get(i)은 i번째 요소의 데이터 값을 얻음.

향상된 for문 
```java
for(Book lang:library)
		{
			lang.showinfo();
		}
```

상위 클래스로 형 변환이 된 하위클래스는 재정의된 메소드(가상 메소드)를 호출한다.

하위 클래스에서 재정의 된 메소드(@Override 애노테이션을 사용)는 오버라이드를 했다.

변수가 사용하는 메모리(힙)와 **메소드가 사용하는 메모리는 다르다**

클래스의 메소드 명령 집합은 **메소드 영역(코드 영역)에 위치** 해서 메소드를 호출하면 메소드 영역의 주소를 참조하여 명령이 실행.

가상메소드의 경우에는 **가상 메소드 테이블**이 따로 만들어진다. 각 메소드 이름과 실제 메모리 주소가 짝을 이루고 있음. 어떤 메소드가 호출되면 이 테이블에서 주소 값을 찾아서 해당 메소드의 명령을 수행

ex) 상위 클래스 a ( 메소드1, 메소드2가 존재) a클래스의 확장인 클래스 b (a의 메소드1을 재정의한 메소드, 재정의되지 않은 메소드2, 추가한 메소드3)
        하위 클래스에서 재정의된 메소드는 하위클래스의 메소드 영역을 참조.

재정의되지 않은 메소드는 메소드 주소가 상위클래스와 하위클래스 모두 같으며 상위클래스의 메소드를 호출.

하위클래스를 선언을 하고, 상위 클래스로 형변환을 하고 나서 함수를 호출하면 **가상 메소드 방식(생성된 인스턴스의 메소드 호출)에 의해서 하위클래스의 메소드가 실행된다 **(단 상위클래스에서 하위클래스로의 형변환은 불가하다)

상속받은 클래스들도 존재하고 ArrayList를 사용하려고 한다면 , ArrayList의 선언은 제일 상위 클래스로 선언을 하면 묵시적으로 모두 상위클래스로 형변환된다. **다형성**에 의해 실제 인스턴스가 무엇이냐에 따라 재정의한 메서드를 각각 호출하여 계산.

**IS-A관계 : 일반적인 개념과 구체적인 개념의 관계 (ex)사람은 표유류이다)**

**HAS-A관계 : 한 클래스가 다른 클래스를 소유한 관계 **

**다운 캐스팅: 상위 클래스로 형 변환되었던 하위 클래스를 다시 원래 자료형으로 형 변환하는 것**

**instance of 예약어 -> 변수 instance of 클래스 = 왼쪽에 있는 변수가 원래 인스턴스형이 오른쪽 클래스 자료형인지 확인** 

상위 클래스로의 형변환은 암묵적이지만, 하위 클래스로의 형변환은 명시적이어야한다. 
